<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Untitled Document</title>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<title>Untitled Document</title>
		<script type=text/javascript charset=utf-8 src=CommonUtil.js ></script>
		<script type=text/javascript charset=utf-8>		
				
				//装饰者模式：就是在保证不改变原有对象的基础上，去扩展一些想要的方法或去求
				// 实现同样的接口
				// 需要有子类
				
				/* var CarInterface = new SANWU.Interface('CarInterface' , ['getPrice' , 'assemble']);
				var Car = function(car){
					//就是为了让子类继承的 （让子类 多一个父类的引用）
					this.car = car ; 
					//检查接口
					SANWU.Interface.ensureImplements(this , CarInterface);
				};
				Car.prototype = {
					constructor :Car,
					getPrice:function(){
						return 200000 ; 
					},
					assemble:function(){
						document.write('组装汽车...');
					}
				};
				
				//新的需求：light、refrigerator .......
				
				var LightDecorator = function(car){ //原始对象
					//借用构造函数继承
					LightDecorator.superClass.constructor.call(this , car);
				};
				SANWU.extend(LightDecorator , Car);  //原型继承 
				
				LightDecorator.prototype = {
					constructor:LightDecorator , 
					getPrice:function(){
						return  this.car.getPrice() + 10000; 
					},
					assemble:function(){
						document.write('组装车灯...');
					}					
				};
				
				var RefrigeratorDecorator = function(car){
					//借用构造函数继承
					RefrigeratorDecorator.superClass.constructor.call(this , car);					
				};
				SANWU.extend(RefrigeratorDecorator , Car);  //原型继承 
				
				RefrigeratorDecorator.prototype = {
					constructor:RefrigeratorDecorator , 
					getPrice:function(){
						return  this.car.getPrice() + 20000; 
					},
					assemble:function(){
						document.write('组装车载冰箱...');
					}					
				};				
				
				
				
				var car  = new Car();
				alert(car.getPrice());
				car.assemble();
				
				car = new LightDecorator(car);
				alert(car.getPrice());
				car.assemble();		
				
				car = new RefrigeratorDecorator(car);
				alert(car.getPrice());
				car.assemble();	 */				
				
				
				
				
				//装饰者 不仅可以用在类上， 还可以用在函数上
				
				
				//返回一个当前时间的字符串表示形式
				function getDate(){
					return (new Date()).toString();
				};
				
				// 包装函数 (装饰者函数)
				function upperCaseDecorator(fn){
					return function(){
						return fn.apply(this, arguments).toUpperCase();
					}
				};
				
				alert(getDate());
				
				var getDecoratorDate = upperCaseDecorator(getDate);
				
				alert(getDecoratorDate());
				
				
				
					
		</script>
	</head>
	<body>
	</body>
</html>
